var charToInteger = {};
var integerToChar = {};
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach(function (char, i) {
    charToInteger[char] = i;
    integerToChar[i] = char;
});
function decode(string) {
    var result = [];
    var shift = 0;
    var value = 0;
    for (var i = 0; i < string.length; i += 1) {
        var integer = charToInteger[string[i]];
        if (integer === undefined) {
            throw new Error('Invalid character (' + string[i] + ')');
        }
        var hasContinuationBit = integer & 32;
        integer &= 31;
        value += integer << shift;
        if (hasContinuationBit) {
            shift += 5;
        }
        else {
            var shouldNegate = value & 1;
            value >>= 1;
            result.push(shouldNegate ? -value : value);
            // reset
            value = shift = 0;
        }
    }
    return result;
}
function encode(value) {
    var result;
    if (typeof value === 'number') {
        result = encodeInteger(value);
    }
    else {
        result = '';
        for (var i = 0; i < value.length; i += 1) {
            result += encodeInteger(value[i]);
        }
    }
    return result;
}
function encodeInteger(num) {
    var result = '';
    if (num < 0) {
        num = (-num << 1) | 1;
    }
    else {
        num <<= 1;
    }
    do {
        var clamped = num & 31;
        num >>= 5;
        if (num > 0) {
            clamped |= 32;
        }
        result += integerToChar[clamped];
    } while (num > 0);
    return result;
}

function decodeSegments(encodedSegments) {
    var i = encodedSegments.length;
    var segments = new Array(i);
    while (i--)
        segments[i] = decode(encodedSegments[i]);
    return segments;
}
function decode$1(mappings) {
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var lines = mappings.split(';');
    var numLines = lines.length;
    var decoded = new Array(numLines);
    var i;
    var j;
    var line;
    var generatedCodeColumn;
    var decodedLine;
    var segments;
    var segment;
    var result;
    for (i = 0; i < numLines; i += 1) {
        line = lines[i];
        generatedCodeColumn = 0; // first field - reset each time
        decodedLine = [];
        segments = decodeSegments(line.split(','));
        for (j = 0; j < segments.length; j += 1) {
            segment = segments[j];
            if (!segment.length) {
                break;
            }
            generatedCodeColumn += segment[0];
            result = [generatedCodeColumn];
            decodedLine.push(result);
            if (segment.length === 1) {
                // only one field!
                continue;
            }
            sourceFileIndex += segment[1];
            sourceCodeLine += segment[2];
            sourceCodeColumn += segment[3];
            result.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);
            if (segment.length === 5) {
                nameIndex += segment[4];
                result.push(nameIndex);
            }
        }
        decoded[i] = decodedLine;
    }
    return decoded;
}
function encode$1(decoded) {
    var offsets = {
        generatedCodeColumn: 0,
        sourceFileIndex: 0,
        sourceCodeLine: 0,
        sourceCodeColumn: 0,
        nameIndex: 0 // fifth field
    };
    return decoded.map(function (line) {
        offsets.generatedCodeColumn = 0; // first field - reset each time
        return line.map(encodeSegment).join(',');
    }).join(';');
    function encodeSegment(segment) {
        if (!segment.length) {
            return '';
        }
        var result = new Array(segment.length);
        result[0] = segment[0] - offsets.generatedCodeColumn;
        offsets.generatedCodeColumn = segment[0];
        if (segment.length === 1) {
            // only one field!
            return encode(result);
        }
        result[1] = segment[1] - offsets.sourceFileIndex;
        result[2] = segment[2] - offsets.sourceCodeLine;
        result[3] = segment[3] - offsets.sourceCodeColumn;
        offsets.sourceFileIndex = segment[1];
        offsets.sourceCodeLine = segment[2];
        offsets.sourceCodeColumn = segment[3];
        if (segment.length === 5) {
            result[4] = segment[4] - offsets.nameIndex;
            offsets.nameIndex = segment[4];
        }
        return encode(result);
    }
}

export { decode$1 as decode, encode$1 as encode };
//# sourceMappingURL=sourcemap-codec.es.js.map
